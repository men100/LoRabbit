/*
 * EK-RA8D1 LCD Example for Î¼T-Kernel 3.0 BSP2
 *
 * Copyright (C) 2025 by Ken Sakamura.
 * This software is distributed under the T-License 2.1.
 *----------------------------------------------------------------------
 *
 * Released by TRON Forum(http://www.tron.org) at 2025/06.
 */
/*
 * tglib.c  Tiny graphics library (RGB565 version)
 */

#include "tglib.h"

/*
 * 8x16 ASCII Font data (Characters from ' ' to '~')
 */
static const unsigned char FONT_8X16[95][16] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // Space
    {0x00,0x00,0x00,0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // !
    {0x00,0x00,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // "
    {0x00,0x00,0x00,0x24,0x7E,0x24,0x7E,0x24,0x00,0x00,0x24,0x7E,0x24,0x7E,0x24,0x00}, // #
    {0x00,0x00,0x18,0x3C,0x60,0x38,0x0C,0x78,0x30,0x06,0x1E,0x18,0x00,0x00,0x00,0x00}, // $
    {0x00,0x00,0x00,0x60,0x66,0x0C,0x18,0x30,0x60,0x46,0x62,0x06,0x00,0x00,0x00,0x00}, // %
    {0x00,0x00,0x3C,0x66,0x6E,0x3C,0x18,0x3A,0x66,0x66,0x3A,0x00,0x00,0x00,0x00,0x00}, // &
    {0x00,0x00,0x00,0x18,0x18,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // '
    {0x00,0x00,0x0C,0x18,0x30,0x60,0x60,0x60,0x60,0x30,0x18,0x0C,0x00,0x00,0x00,0x00}, // (
    {0x00,0x00,0x30,0x18,0x0C,0x06,0x06,0x06,0x06,0x0C,0x18,0x30,0x00,0x00,0x00,0x00}, // )
    {0x00,0x00,0x00,0x00,0x00,0x2A,0x1C,0x7F,0x1C,0x2A,0x00,0x00,0x00,0x00,0x00,0x00}, // *
    {0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // +
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30,0x60,0x00,0x00,0x00}, // ,
    {0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // -
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // .
    {0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // /
    {0x00,0x00,0x3C,0x66,0x6E,0x76,0x7E,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // 0
    {0x00,0x00,0x18,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,0x00}, // 1
    {0x00,0x00,0x3C,0x66,0x06,0x0C,0x18,0x30,0x60,0x66,0x7E,0x00,0x00,0x00,0x00,0x00}, // 2
    {0x00,0x00,0x3C,0x66,0x06,0x06,0x3C,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // 3
    {0x00,0x00,0x0C,0x1C,0x3C,0x6C,0x66,0x7E,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00,0x00}, // 4
    {0x00,0x00,0x7E,0x60,0x60,0x7C,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // 5
    {0x00,0x00,0x3C,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // 6
    {0x00,0x00,0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // 7
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // 8
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x3E,0x06,0x06,0x0C,0x38,0x00,0x00,0x00,0x00,0x00}, // 9
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // :
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x60,0x00,0x00,0x00}, // ;
    {0x00,0x00,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // <
    {0x00,0x00,0x00,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // =
    {0x00,0x00,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // >
    {0x00,0x00,0x3C,0x66,0x06,0x0C,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // ?
    {0x00,0x00,0x3C,0x66,0x66,0x6C,0x7C,0x76,0x66,0x60,0x3E,0x00,0x00,0x00,0x00,0x00}, // @
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00}, // A
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00,0x00}, // B
    {0x00,0x00,0x3C,0x66,0x60,0x60,0x60,0x60,0x60,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // C
    {0x00,0x00,0x78,0x6C,0x66,0x66,0x66,0x66,0x66,0x6C,0x78,0x00,0x00,0x00,0x00,0x00}, // D
    {0x00,0x00,0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00,0x00}, // E
    {0x00,0x00,0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00}, // F
    {0x00,0x00,0x3C,0x66,0x60,0x60,0x6E,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00}, // G
    {0x00,0x00,0x66,0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00}, // H
    {0x00,0x00,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,0x00}, // I
    {0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0x78,0x00,0x00,0x00,0x00,0x00}, // J
    {0x00,0x00,0x66,0x6C,0x78,0x70,0x7C,0x70,0x78,0x6C,0x66,0x00,0x00,0x00,0x00,0x00}, // K
    {0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00,0x00}, // L
    {0x00,0x00,0xC6,0xEE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,0x00}, // M
    {0x00,0x00,0x66,0xE6,0xF6,0xDE,0xCE,0x6E,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00}, // N
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // O
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00}, // P
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x6E,0x3C,0x0C,0x0E,0x00,0x00,0x00,0x00}, // Q
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x78,0x6C,0x66,0x66,0x00,0x00,0x00,0x00,0x00}, // R
    {0x00,0x00,0x3C,0x66,0x60,0x3C,0x06,0x06,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // S
    {0x00,0x00,0x7E,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // T
    {0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // U
    {0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // V
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0xFE,0xEE,0xC6,0x00,0x00,0x00,0x00,0x00}, // W
    {0x00,0x00,0x66,0x66,0x3C,0x18,0x18,0x3C,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00}, // X
    {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // Y
    {0x00,0x00,0x7E,0x06,0x0C,0x18,0x30,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00,0x00}, // Z
    {0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00,0x00}, // [
    {0x00,0x00,0x40,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // backslash
    {0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00,0x00}, // ]
    {0x00,0x00,0x08,0x1C,0x36,0x62,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // ^
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00}, // _
    {0x00,0x00,0x18,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // `
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x06,0x3E,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00}, // a
    {0x00,0x00,0x60,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00,0x00}, // b
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x60,0x60,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // c
    {0x00,0x00,0x06,0x06,0x06,0x3E,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00}, // d
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x7E,0x60,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // e
    {0x00,0x00,0x1C,0x36,0x30,0x7C,0x30,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,0x00}, // f
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00,0x00,0x00}, // g
    {0x00,0x00,0x60,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00}, // h
    {0x00,0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,0x00}, // i
    {0x00,0x00,0x00,0x0C,0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0xCC,0x78,0x00,0x00,0x00}, // j
    {0x00,0x00,0x60,0x60,0x60,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00,0x00,0x00,0x00,0x00}, // k
    {0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,0x00}, // l
    {0x00,0x00,0x00,0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xD6,0xC6,0x00,0x00,0x00,0x00,0x00}, // m
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00}, // n
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // o
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x00,0x00,0x00}, // p
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0x66,0x66,0x3E,0x06,0x06,0x0E,0x00,0x00,0x00}, // q
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x6E,0x66,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00}, // r
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00,0x00,0x00,0x00,0x00,0x00}, // s
    {0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00}, // t
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00}, // u
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // v
    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00,0x00,0x00,0x00,0x00}, // w
    {0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00,0x00,0x00,0x00,0x00}, // x
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x0C,0x78,0x00,0x00,0x00,0x00}, // y
    {0x00,0x00,0x00,0x00,0x00,0x7E,0x0C,0x18,0x30,0x60,0x7E,0x00,0x00,0x00,0x00,0x00}, // z
    {0x00,0x00,0x0E,0x18,0x18,0x30,0x60,0x60,0x30,0x18,0x18,0x0E,0x00,0x00,0x00,0x00}, // {
    {0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00}, // |
    {0x00,0x00,0x70,0x18,0x18,0x0C,0x06,0x06,0x0C,0x18,0x18,0x70,0x00,0x00,0x00,0x00}, // }
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x34,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // ~
};

/*--------------------------------------------------------------------------------------------*/
/*
 * Semaphore for exclusive control of library API
 */
LOCAL ID    tlib_semid;
LOCAL T_CSEM    csem = {
    .isemcnt = 1,
    .maxsem  = 1,
    .sematr  = TA_TFIFO | TA_FIRST,
};
#define TLIBLCD_LOCK     tk_wai_sem(tlib_semid, 1, TMO_FEVR);
#define TLIBLCD_UNLOCK   tk_sig_sem(tlib_semid, 1);

/*
 * local definition
 */
LOCAL UH    max_x, max_y;
LOCAL UW    buffer_size, hstride;
LOCAL UH    *p_frame_buffer;

LOCAL void draw_rect (UH color, UW posX, UW posY, UW width, UW height);

/*--------------------------------------------------------------------------------------------*/
/*
 * LCD Library API
 */

 /*
 * Initialize library
 */
ER tglib_init(void)
{
    fsp_err_t   err = FSP_SUCCESS;

    /* Initialize GLCDC module */
    err = R_GLCDC_Open(&g_display_ctrl, &g_display_cfg);
    if(FSP_SUCCESS != err) return E_IO;

    /* Initialize LCD Controller (mipi_dsi_ep.c) */
    mipi_dsi_push_table(g_lcd_init_focuslcd);

    /* Get LCDC configuration */
    max_x = (g_display_cfg.input[0].hsize);
    max_y = (g_display_cfg.input[0].vsize);
    hstride = (g_display_cfg.input[0].hstride);

    /* Initialize buffer pointers */
    buffer_size = (UW) (max_x * max_y * 2);
    p_frame_buffer = (UH*) g_display_cfg.input[0].p_base;

    err = R_GLCDC_BufferChange (&g_display_ctrl, (uint8_t*) p_frame_buffer, DISPLAY_FRAME_LAYER_1);
    if(FSP_SUCCESS != err) return E_IO;

    tlib_semid = tk_cre_sem(&csem);
    return(tlib_semid > E_OK? E_OK: (ER)tlib_semid);
}

/* * Get display size - Height
 */
UW tglib_get_height(void)
{
    return max_y;
}

/* * Get display size - Width
 */
UW tglib_get_width(void)
{
    return max_x;
}

/*
 * LCD ON/OFF
*/
ER tglib_onoff_lcd(UINT status)
{
    TLIBLCD_LOCK

    fsp_err_t   err = FSP_SUCCESS;

    if(status == LCD_ON) {
        err = R_GLCDC_Start(&g_display_ctrl);
        if(FSP_SUCCESS != err) goto L_RETURN;
        draw_rect (TLIBLCD_COLOR_WHITE, 0, 0, max_x, max_y);
    } else {
        draw_rect (TLIBLCD_COLOR_BLACK, 0, 0, max_x, max_y);
        err = R_GLCDC_Stop(&g_display_ctrl);
    }

L_RETURN:
    TLIBLCD_UNLOCK
    return (FSP_SUCCESS != err)? E_OK: E_IO;
}

/*
 * Clear Screen
*/
void tglib_clear_scr(UH color)
{
    TLIBLCD_LOCK
    draw_rect (color, 0, 0, max_x, max_y);
    TLIBLCD_UNLOCK
}

/*
 * Draw a rectangle
 */
void tglib_draw_rect(UH color, UW posX, UW posY, UW width, UW height)
{
    if((posX >= max_x)||(posY >= max_y)) return;

    if(max_x <= (posX + width)) width -= (posX + width)-max_x;
    if(max_y <= (posY + height)) height -= (posY + height)-max_y;

    TLIBLCD_LOCK
    draw_rect (color, posX, posY, width, height);
    TLIBLCD_UNLOCK
}

/*--------------------------------------------------------------------------------------------*/
/* * Library local functions
 */
/* * Draw a rectangle
 */
LOCAL void draw_rect (UH color, UW posX, UW posY, UW width, UW height)
{
    UW xx = ( max_x <= (posX + width) ) ? max_x : (posX + width);
    UW yy = ( max_y <= (posY + height) ) ? max_y : (posY + height);
    UH *p_fb = p_frame_buffer + ( hstride * posY );

    for (UW y = posY; y < yy; y++)
    {
        for (UW x = posX; x < xx; x ++)
        {
            // RGB565 ã«ããã¨ãè²åè»¢ã¢ã¼ããæå¹ã«ãªãããã§ãcolor ã®ããããåè»¢ããã¨ãã¾ãããæ¨¡æ§
            p_fb[x] = ~color;
        }
        p_fb += hstride;
    }
}

/**
 * @brief Draws a single character on the screen.
 *
 * @param character The ASCII character to draw.
 * @param posX      X-coordinate of the top-left corner.
 * @param posY      Y-coordinate of the top-left corner.
 * @param color     Color of the character.
 */
void tglib_draw_char(char character, UW posX, UW posY, UH color)
{
    // Return if character is not in our font table
    if (character < ' ' || character > '~') {
        return;
    }

    // Return if the character is completely off-screen
    if (posX >= max_x || posY >= max_y) {
        return;
    }

    // Get pointer to the font data for the specific character
    const unsigned char *font_data = FONT_8X16[character - ' '];

    // Pre-invert the color
    UH inverted_color = ~color;

    TLIBLCD_LOCK

    // Loop through each row of the character (16 rows)
    for (UW y = 0; y < FONT_HEIGHT; y++) {
        UW current_posY = posY + y;

        // Don't draw if row is off-screen
        if (current_posY >= max_y) {
            break;
        }

        // Get the byte that represents the current row of the character bitmap
        unsigned char row_data = font_data[y];

        // Get the starting address of the current line in the framebuffer
        UH *p_fb_line = p_frame_buffer + (hstride * current_posY);

        // Loop through each bit/pixel of the row (8 pixels)
        for (UW x = 0; x < FONT_WIDTH; x++) {
            UW current_posX = posX + x;

            // Don't draw if pixel is off-screen
            if (current_posX >= max_x) {
                continue;
            }

            // Check if the leftmost bit is set
            if (row_data & 0x80) {
                // If the bit is set, draw the pixel
                p_fb_line[current_posX] = inverted_color;
            }

            // Shift the bits to the left to process the next pixel
            row_data <<= 1;
        }
    }
    TLIBLCD_UNLOCK
}

/**
 * @brief Draws a string of characters on the screen.
 *
 * @param str       Null-terminated string to draw.
 * @param posX      X-coordinate of the top-left corner of the first character.
 * @param posY      Y-coordinate of the top-left corner of the first character.
 * @param color     Color of the string.
 */
void tglib_draw_string(const char *str, UW posX, UW posY, UH color)
{
    if (str == NULL) {
        return;
    }

    UW current_posX = posX;
    UW current_posY = posY;

    while (*str != '\0') {
        // If the character would go off the right edge of the screen,
        // move to the next line (word wrap)
        if (current_posX + FONT_WIDTH > max_x) {
            current_posY += FONT_HEIGHT;
            current_posX = posX;
        }

        // If the text goes off the bottom of the screen, stop drawing
        if (current_posY >= max_y) {
            return;
        }

        tglib_draw_char(*str, current_posX, current_posY, color);

        current_posX += FONT_WIDTH;
        str++;
    }
}

/**
 * @brief Draws a single character on the screen with scaling.
 *
 * @param character The ASCII character to draw.
 * @param posX      X-coordinate of the top-left corner.
 * @param posY      Y-coordinate of the top-left corner.
 * @param color     Color of the character.
 * @param scale     Scaling factor (e.g., 2 for double size).
 */
void tglib_draw_char_scaled(char character, UW posX, UW posY, UH color, UW scale)
{
    if (scale == 0) return;
    if (character < ' ' || character > '~') return;

    const unsigned char *font_data = FONT_8X16[character - ' '];

    TLIBLCD_LOCK

    for (UW y = 0; y < FONT_HEIGHT; y++)
    {
        unsigned char row_data = font_data[y];
        for (UW x = 0; x < FONT_WIDTH; x++)
        {
            if (row_data & 0x80)
            {
                // Draw a rectangle of scale x scale for each pixel
                draw_rect(color, posX + (x * scale), posY + (y * scale), scale, scale);
            }
            row_data <<= 1;
        }
    }
    TLIBLCD_UNLOCK
}

/**
 * @brief Draws a string of characters on the screen with scaling.
 *
 * @param str       Null-terminated string to draw.
 * @param posX      X-coordinate of the top-left corner of the first character.
 * @param posY      Y-coordinate of the top-left corner of the first character.
 * @param color     Color of the string.
 * @param scale     Scaling factor (e.g., 2 for double size).
 */
void tglib_draw_string_scaled(const char *str, UW posX, UW posY, UH color, UW scale)
{
    if (str == NULL || scale == 0) {
        return;
    }

    UW current_posX = posX;
    UW current_posY = posY;
    UW char_width = FONT_WIDTH * scale;
    UW char_height = FONT_HEIGHT * scale;


    while (*str != '\0') {
        if (current_posX + char_width > max_x) {
            current_posY += char_height;
            current_posX = posX;
        }

        if (current_posY >= max_y) {
            return;
        }

        tglib_draw_char_scaled(*str, current_posX, current_posY, color, scale);

        current_posX += char_width;
        str++;
    }
}

/**
 * @brief Draws a buffer of RGB565 pixels onto the screen.
 *
 * @param buffer    Pointer to the source buffer containing RGB565 pixel data.
 * @param posX      X-coordinate of the top-left corner on the screen.
 * @param posY      Y-coordinate of the top-left corner on the screen.
 * @param width     Width of the source buffer.
 * @param height    Height of the source buffer.
 */
void tglib_draw_buffer(const UH *buffer, UW posX, UW posY, UW width, UW height)
{
    // æç»éå§/çµäºåº§æ¨ãè¨ç®
    UW x_start = posX;
    UW y_start = posY;
    UW x_end   = posX + width;
    UW y_end   = posY + height;

    // æç»é åãå®å¨ã«ç»é¢å¤ã®å ´åã¯ä½ãããªã
    if (x_start >= max_x || y_start >= max_y) {
        return;
    }

    // ç»é¢ã®å³ç«¯/ä¸ç«¯ããã¯ã¿åºãé¨åãã«ãã
    if (x_end > max_x) {
        x_end = max_x;
    }
    if (y_end > max_y) {
        y_end = max_y;
    }

    // å®éã«æç»ããå¹ãåè¨ç®
    UW copy_width = x_end - x_start;

    TLIBLCD_LOCK

    // æç»é åã®åè¡ãã«ã¼ã
    for (UW y = y_start; y < y_end; y++) {
        // ã³ãã¼åãããã¡ã®ç¾å¨è¡ã®åé ­ãã¤ã³ã¿ãè¨ç®
        // (y - posY) ã§ãåã®ãããã¡ã®ä½è¡ç®ããç®åºããã®ããã¤ã³ã
        const UH *p_src = buffer + ((y - posY) * width);

        // ã³ãã¼åï¼ãã¬ã¼ã ãããã¡ï¼ã®ç¾å¨è¡ã®åé ­ãã¤ã³ã¿ãè¨ç®
        UH *p_dst = p_frame_buffer + (y * hstride) + x_start;

        // 1è¡åã®ãã¯ã»ã«ãã¼ã¿ãã³ãã¼ï¼è²åè»¢ãé©ç¨ï¼
        for (UW i = 0; i < copy_width; i++) {
            p_dst[i] = ~p_src[i];
        }
    }

    TLIBLCD_UNLOCK
}

/**
 * @brief Draws a buffer of RGB565 pixels onto the screen with scaling.
 *
 * @param buffer    Pointer to the source buffer containing RGB565 pixel data.
 * @param posX      X-coordinate of the top-left corner on the screen.
 * @param posY      Y-coordinate of the top-left corner on the screen.
 * @param width     Width of the source buffer.
 * @param height    Height of the source buffer.
 * @param scale     Scaling factor (e.g., 2 for double size).
 */
void tglib_draw_buffer_scaled(const UH *buffer, UW posX, UW posY, UW width, UW height, UW scale)
{
    // æ¡å¤§çã0ã®å ´åã¯ä½ãããªã
    if (scale == 0) {
        return;
    }

    TLIBLCD_LOCK

    // åãããã¡ã®åãã¯ã»ã«ãã«ã¼ã
    for (UW y = 0; y < height; y++) {
        for (UW x = 0; x < width; x++) {
            // åãããã¡ãã1ãã¯ã»ã«ã®è²ãåå¾
            UH pixel_color = buffer[y * width + x];

            // æ¡å¤§å¾ã®åº§æ¨ãè¨ç®ããscale x scale ã®ç©å½¢ãæç»
            draw_rect(pixel_color, posX + (x * scale), posY + (y * scale), scale, scale);
        }
    }

    TLIBLCD_UNLOCK
}
